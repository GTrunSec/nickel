%use "ast".

eval : expr -> expr -> prop.

(* Lazy evaluation *)
eval (thunk _ E V) V' when refl.isunif V :-
  eval E V,
  eq V V'.
eval (thunk _ E V) V' when not (refl.isunif V) :-
  eq V V'.

eval (recThunk S E V) V' when refl.isunif V :-
  eval (E (recThunk S E R)) V,
  eq V V'.

eval (recThunk _ E V) V' when not (refl.isunif V) :-
  eq V V'.

(* Lambda constructs *)
eval (let (bind Name E) (bind Name T)) V :-  
  eval (T (recThunk Name E V')) V. 

eval (lam X_Body) (lam X_Body).

eval (app E1 E2) V :-   (* Beta *)
  eval E1 (lam (bind Name Body)),
  eval (Body (thunk Name E2 Shr)) V.

(* Constants *)
eval (eint N) (eint N).
eval (ebool B) (ebool B).
eval (estr S) (estr S).
eval (label S) (label S).

eval (inter_label Z Y E) (inter_label Z Y V) :-
  eval E V.
eval (union_label Z Y E) (union_label Z Y V) :-
  eval E V.
eval (fun_dom_label Z E) (fun_dom_label Z V) :-
  eval E V.
eval (fun_codom_label Z E) (fun_codom_label Z V) :-
  eval E V.


(* Operations *)
eval (ite C T E) V :-
  eval C (ebool true),
  eval T V.
eval (ite C T E) V :-
  eval C (ebool false),
  eval E V.

eval_binop : binop -> expr -> expr -> expr -> prop.

eval (ebinop E1 Op E2) V :-
  map eval [E1, E2] [V1, V2],
  eval_binop Op V1 V2 V.

eval_binop add (eint N1) (eint N2) (eint N) :- plus N1 N2 N.
eval_binop sub (eint N1) (eint N2) (eint N) :- plus N2 N N1.
eval_binop mul (eint N1) (eint N2) (eint N) :- mult N1 N2 N.
eval_binop eqNum (eint N1) (eint N2) (ebool B) :- if eq N1 N2 then eq B true else eq B false.

eval_unop : unop -> expr -> expr -> prop.

eval (eunop Op E) V :-
  eval E E',
  eval_unop Op E' V.

(* Blame *)
solve_blame : bool -> expr -> expr -> prop.

solve_blame true _ (label S) :-
  print `Reached a positive blame with label ${S}`,
  failure.
solve_blame false _ (label S) :-
  print `Reached a negative blame with label ${S}`,
  failure.

solve_blame true T (inter_label _ _ L) :-
  solve_blame true T L.
solve_blame false T (inter_label Y Z L) when refl.isunif Y :-
  eq Z true.
solve_blame false T (inter_label Y Z L) when not (refl.isunif Y) :-
  eq Z true,
  solve_blame false T L.

solve_blame true T (union_label Y Z L) when refl.isunif Y :-
  eq Z true.
solve_blame true T (union_label Y Z L) when not (refl.isunif Y) :-
  eq Z true,
  solve_blame true T L.
solve_blame false T (union_label _ _ L) :-
  solve_blame false T L.

solve_blame true T (fun_dom_label Z L) :-
  eq Z true,
  solve_blame false T L.
solve_blame false T (fun_dom_label Z L) :-
  (* eq Z true, *)
  solve_blame true T L.

solve_blame B T (fun_codom_label Z L) when refl.isunif Z :-
  solve_blame B T L.
solve_blame _ T (fun_codom_label Z L) when not (refl.isunif Z).


eval_unop (blame T) L V :-
  solve_blame true T L,
  eval T V.

eval_unop isNum (eint _) (ebool true).
eval_unop isBool (ebool _) (ebool true).
eval_unop isStr (estr _) (ebool true).
eval_unop isFun (lam _) (ebool true).
eval_unop isZero (eint 0) (ebool true).

eval_unop isNum V (ebool false) :- not (eq V (eint _)).
eval_unop isBool V (ebool false) :- not (eq V (ebool _)).
eval_unop isStr V (ebool false) :- not (eq V (estr _)).
eval_unop isFun V (ebool false) :- not (eq V (lam _)).
eval_unop isZero (eint V) (ebool false) :- not (eq V 0).

(* Typing *)
(* Promises don't perform any computation *)
eval (promise _ T) V :-
  eval T V.

eval (assume Ty L T) V :-
  typToExpr Ty CTy,
  eval (app (app CTy L) T) V.

(* Variables *)
eval (named X) _ :- print `unknown variable ${X}`, failure.
