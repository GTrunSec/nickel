%use "ast".

ctx : type.
eval : expr -> expr -> prop.
eval_ctx : ctx -> expr -> expr -> prop.

eval E V :-
  eval_ctx Z E V.

(* Lazy evaluation *)
thunk : string -> ctx -> expr -> expr -> expr.
recThunk : string -> ctx -> (expr -> expr) -> expr -> expr.


eval_ctx _ (thunk _ Z E V) V' when refl.isunif V :-
  eval_ctx Z E V,
  eq V V'.
eval_ctx _ (thunk _ _ E V) V' when not (refl.isunif V) :-
  eq V V'.

eval_ctx _ (recThunk S Z E V) V' when refl.isunif V :-
  eval_ctx Z (E (recThunk S Z E R)) V,
  eq V V'.

eval_ctx _ (recThunk _ _ E V) V' when not (refl.isunif V) :-
  eq V V'.

(* Lambda constructs *)
eval_ctx Z (let (bind Name E) (bind Name T)) V :-  
  eval_ctx Z (T (recThunk Name Y E V')) V. 

eval_ctx Z (lam X_Body) (lam X_Body).

eval_ctx Z (app E1 E2) V :-   (* Beta *)
  eval_ctx Y E1 (lam (bind Name Body)),
  eval_ctx Z (Body (thunk Name R E2 Shr)) V.

(* Constants *)
eval_ctx _ (eint N) (eint N).
eval_ctx _ (ebool B) (ebool B).
eval_ctx _ (estr S) (estr S).
eval_ctx _ (label S) (label S).

eval_ctx C (inter_label Z Y E) (inter_label Z Y V) :-
  eval_ctx C E V.
eval_ctx C (union_label Z Y E) (union_label Z Y V) :-
  eval_ctx C E V.
eval_ctx C (fun_dom_label Z E) (fun_dom_label Z V) :-
  eval_ctx C E V.
eval_ctx C (fun_codom_label Z E) (fun_codom_label Z V) :-
  eval_ctx C E V.


(* Operations *)
eval_ctx Z (ite C T E) V :-
  eval_ctx Y C (ebool true),
  eval_ctx  Z T V.
eval_ctx Z (ite C T E) V :-
  eval_ctx Y C (ebool false),
  eval_ctx Z E V.

eval_binop : binop -> expr -> expr -> expr -> prop.

eval_ctx Z (ebinop E1 Op E2) V :-
  eval_ctx R E1 V1,
  eval_ctx Y E2 V2,
  eval_binop Op V1 V2 V.

eval_binop add (eint N1) (eint N2) (eint N) :- plus N1 N2 N.
eval_binop sub (eint N1) (eint N2) (eint N) :- plus N2 N N1.
eval_binop mul (eint N1) (eint N2) (eint N) :- mult N1 N2 N.
eval_binop eqNum (eint N1) (eint N2) (ebool B) :- if eq N1 N2 then eq B true else eq B false.

eval_unop : unop -> expr -> expr -> prop.

eval_ctx Z (eunop Op E) V :-
  eval_ctx Z E E',
  eval_unop Op E' V',
  eval_ctx Z V' V.

(* Blame *)
pol : type.
pos : pol.
neg : ctx -> pol.

solve_blame : pol -> expr -> expr -> prop.

solve_blame pos _ (label S) :-
  print `Reached a positive blame with label ${S}`,
  failure.
solve_blame false _ (label S) :-
  print `Reached a negative blame with label ${S}`,
  failure.

solve_blame pos T (inter_label _ _ L) :-
  solve_blame pos T L.
solve_blame false T (inter_label Y Z L) when refl.isunif Y :-
  eq Z pos.
solve_blame false T (inter_label Y Z L) when not (refl.isunif Y) :-
  eq Z pos,
  solve_blame false T L.

solve_blame pos T (union_label Y Z L) when refl.isunif Y :-
  eq Z pos.
solve_blame pos T (union_label Y Z L) when not (refl.isunif Y) :-
  eq Z pos,
  solve_blame pos T L.
solve_blame false T (union_label _ _ L) :-
  solve_blame false T L.

solve_blame pos T (fun_dom_label Z L) :-
  eq Z pos,
  solve_blame false T L.
solve_blame false T (fun_dom_label Z L) :-
  (* eq Z pos, *)
  solve_blame pos T L.

solve_blame B T (fun_codom_label Z L) when refl.isunif Z :-
  solve_blame B T L.
solve_blame _ T (fun_codom_label Z L) when not (refl.isunif Z).


eval_unop (blame T) L T :-
  solve_blame pos T L.

eval_unop isNum (eint _) (ebool true).
eval_unop isBool (ebool _) (ebool true).
eval_unop isStr (estr _) (ebool true).
eval_unop isFun (lam _) (ebool true).
eval_unop isZero (eint 0) (ebool true).

eval_unop isNum V (ebool false) :- not (eq V (eint _)).
eval_unop isBool V (ebool false) :- not (eq V (ebool _)).
eval_unop isStr V (ebool false) :- not (eq V (estr _)).
eval_unop isFun V (ebool false) :- not (eq V (lam _)).
eval_unop isZero (eint V) (ebool false) :- not (eq V 0).

(* Typing *)
(* Promises don't perform any computation *)
eval_ctx Z (promise _ T) V :-
  eval_ctx Z T V.

eval_ctx Z (assume Ty L T) V :-
  typToExpr Ty CTy,
  eval_ctx Z (app (app CTy L) T) V.

(* Variables *)
eval_ctx Z (named X) _ :- print `unknown variable ${X}`, failure.
