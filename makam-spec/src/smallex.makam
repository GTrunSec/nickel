print "===== INTERSECTION TYPES =====" ?

raw_interpreter "
Assume(/\( Num, Num), 45)
" V T ?

raw_interpreter "
Assume(/\( Bool, Num), 45)
" V T ?

raw_interpreter "
Assume(/\( Num, Num), true)
" V T ?

raw_interpreter "
Assume(/\( (Num -> Num), (Num -> Num)), fun x => x) 43
" V T ?



raw_interpreter "
Assume(/\( (Num -> Num), (/\( (String -> String), (Bool -> Bool) ))), fun x => x) true
" V T ?


raw_interpreter "
let (alwaysFalse = fun l => fun t => Ifte(t, blame t l, t)) in
Assume((alwaysFalse -> alwaysFalse), fun x  => x )
" V T ?

raw_interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
let (alwaysFalse = fun l => fun t => Ifte(t, blame t l, t)) in
Assume(/\( (alwaysTrue -> alwaysFalse), (alwaysFalse -> alwaysTrue)), fun x  => Ifte(x, false, true) ) true
" V T ?


raw_interpreter "
Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23)) true
" V T ?



raw_interpreter "
let (f = Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23))) in
let (g = Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23))) in
(f true) + (g 2)
" V T ?


raw_interpreter "
let (f = Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23))) in
(f true) + (f 2)
" V T ?

raw_interpreter "
let (f = Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23))) in
(f true) + (f (fun x => x))
" V T ?

(x: A -> y: A -> eq x x ) ?


raw_interpreter "
let (f = Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23))) in
f (f true)
" V T ?


raw_interpreter "
let (f = Assume(/\( (Num -> Num), (Bool -> Num)), fun x => Ifte( isNum x, x, 23))) in
(f true) + (f true)
" V T ?


print "===== UNION TYPES =====" ?

raw_interpreter "
Assume(\/( Num, Num), 45)
" V T ?


raw_interpreter "
Assume(\/( Bool, Num), 45)
" V T ?

raw_interpreter "
Assume(\/( Num, String), true)
" V T ?

raw_interpreter "
Assume(\/(Num -> Num, \/(Num -> Bool, Num -> String)), fun x => x + 2) 45
" V T ?

raw_interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
Assume(\/(alwaysTrue -> Num, Bool -> \/(Num, Bool)), fun x => Ifte(x, x, x)) false
" V T ?


raw_interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
Assume(\/(alwaysTrue -> Num, Bool -> \/(Num, Bool)), fun x => Ifte(x, x, x)) true
" V T ?



raw_interpreter "
let (zero = fun l => fun t => Ifte(isZero t, t, blame t l)) in
let (one = fun l => fun t => Ifte(1 =n t, t, blame t l)) in
let (two = fun l => fun t => Ifte(2 =n t, t, blame t l)) in
let (three = fun l => fun t => Ifte(3 =n t, t, blame t l)) in

Assume(\/(\/(zero, two), one), 1 )
" V T ?

raw_interpreter "
let (zero = fun l => fun t => Ifte(isZero t, t, blame t l)) in
let (one = fun l => fun t => Ifte(1 =n t, t, blame t l)) in
let (two = fun l => fun t => Ifte(2 =n t, t, blame t l)) in
let (three = fun l => fun t => Ifte(3 =n t, t, blame t l)) in

Assume(\/(\/(zero, two), one), 3 )
" V T ?


raw_interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
let (alwaysFalse = fun l => fun t => Ifte(t, blame t l, t)) in

let (zero = fun l => fun t => Ifte(isZero t, t, blame t l)) in
let (one = fun l => fun t => Ifte(1 =n t, t, blame t l)) in
let (two = fun l => fun t => Ifte(2 =n t, t, blame t l)) in
let (three = fun l => fun t => Ifte(3 =n t, t, blame t l)) in

let (or = fun a => fun b => Ifte(a, true, b)) in

let (f = Assume(\/(Num -> alwaysTrue, Num -> alwaysFalse), fun x => Ifte(isZero x, true, false))) in
(or (f 1)) (f 0)
" V T ?

raw_interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
let (alwaysFalse = fun l => fun t => Ifte(t, blame t l, t)) in

let (zero = fun l => fun t => Ifte(isZero t, t, blame t l)) in
let (notZero = fun l => fun t => Ifte(isZero t, blame t l, t)) in

let (or = fun a => fun b => Ifte(a, true, b)) in

let (f = Assume(/\( zero -> alwaysTrue, notZero -> alwaysFalse), fun x => Ifte(isZero x, true, false))) in
f 0
" V T ?
