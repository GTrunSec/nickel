expr : type.
typ : type.

(* Lambda constructs *)
let : bindone expr expr -> bindone expr expr -> expr.
lam : bindone expr expr -> expr.
app : expr -> expr -> expr.

(* Constants *)
eint : int -> expr.
ebool : bool -> expr.
estr : string -> expr.

(* Operations *)
ite : expr -> expr -> expr -> expr.

unop : type.
eunop : unop -> expr -> expr.
blame : expr -> unop.
isNum : unop.
isBool : unop.
isStr : unop.
isFun : unop.
isZero : unop.

binop : type.
ebinop : expr -> binop -> expr -> expr.
add : binop.
sub : binop.
mul : binop.
eqNum : binop.

(* Typing *)
promise : typ -> expr -> expr.
assume : typ -> expr -> expr -> expr.

(* Blaming *)
label : string -> expr.
neg : expr -> expr.

(* special dependency labels *)
inter_label : bool -> expr -> expr.
union_label : bool -> expr -> expr.
fun_dom_label : bool -> expr -> expr.
fun_codom_label : bool -> expr -> expr.

(* Variables *)
named : string -> expr.

(* These are used for lazy evaluation *)
thunk : string -> expr -> expr -> expr.
recThunk : string -> (expr -> expr) -> expr -> expr.

(* Types *)
tdyn : typ.
tnum : typ.
tbool : typ.
tstr : typ.
tlbl : typ.
tarrow : typ -> typ -> typ.
tinter : typ -> typ -> typ.
tunion : typ -> typ -> typ.
fromExpr : expr -> typ.

(* Get the expression contract of a given type *)
typToExpr : typ -> expr -> prop.
typToExpr tdyn (lam (bind _ (fun l => lam (bind _ 
  (fun t => t))))).
typToExpr tnum (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isNum t) t (eunop (blame t) l)))))).
typToExpr tbool (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isBool t) t (eunop (blame t) l)))))).
typToExpr tstr (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isStr t) t (eunop (blame t) l)))))).
typToExpr (tarrow S T) (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isFun t) (lam (bind _ (fun x => app (app Ct (fun_codom_label Z l)) (app t (app (app Cs (neg (fun_dom_label Z l))) x))))) (eunop (blame t) l)))))) :-
    typToExpr S Cs,
    typToExpr T Ct.

typToExpr (tinter A B) (lam (bind _ (fun l => lam (bind _ (fun t => 
  app (app Ca (inter_label Z l)) (app (app Cb (inter_label Z l)) t)
))))) :-
  typToExpr A Ca,
  typToExpr B Cb.
typToExpr (tunion A B) (lam (bind _ (fun l => lam (bind _ (fun t => 
  app (app Ca (union_label Z l)) (app (app Cb (union_label Z l)) t)
))))) :-
  typToExpr A Ca,
  typToExpr B Cb.

typToExpr (fromExpr E) E.

(* Other *)

find : string -> list (tuple string A) -> A -> prop.
find S [] _ :- log_error S `Not found in record ${S}`, failure.
find S ((S, E) :: _) E.
find S ((S', _) :: TL) E :-
  not (eq S S'),
  find S TL E.
