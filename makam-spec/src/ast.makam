%use "set".

expr : type.
typ : type.
ctx : type.


(* Lambda constructs *)
let : bindone expr expr -> bindone expr expr -> expr.
lam : bindone expr expr -> expr.
app : expr -> expr -> expr.
app2 : expr -> expr -> expr.

(* Constants *)
eint : int -> expr.
ebool : bool -> expr.
estr : string -> expr.

(* Operations *)
ite : expr -> expr -> expr -> expr.

unop : type.
eunop : unop -> expr -> expr.
blame : expr -> unop.
isNum : unop.
isBool : unop.
isStr : unop.
isFun : unop.
isZero : unop.

binop : type.
ebinop : expr -> binop -> expr -> expr.
add : binop.
sub : binop.
mul : binop.
eqNum : binop.

(* Typing *)
promise : typ -> expr -> expr.
assume : typ -> expr -> expr -> expr.

(* Blaming *)
label : string -> expr.

(* special dependency labels *)
inter_label : (set ctx) -> (set ctx) -> expr -> expr.
union_label : bool -> bool -> expr -> expr.
fun_dom_label : bool -> ctx -> expr -> expr.
fun_codom_label : bool -> expr -> expr.

(* context getting *)
get_ctxt : (ctx -> expr) -> expr.

(* Variables *)
named : string -> expr.


(* Types *)
tdyn : typ.
tnum : typ.
tbool : typ.
tstr : typ.
tlbl : typ.
tarrow : typ -> typ -> typ.
tinter : typ -> typ -> typ.
tunion : typ -> typ -> typ.
fromExpr : expr -> typ.

(* Get the expression contract of a given type *)
typToExpr : typ -> expr -> prop.
typToExpr tdyn (lam (bind _ (fun l => lam (bind _ 
  (fun t => t))))).
typToExpr tnum (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isNum t) t (eunop (blame t) l)))))).
typToExpr tbool (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isBool t) t (eunop (blame t) l)))))).
typToExpr tstr (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isStr t) t (eunop (blame t) l)))))).

typToExpr (tarrow S T) (lam (bind _ (fun l => lam (bind _ (fun t => 
  ite (eunop isFun t) 
    (lam (bind _ (fun x => 
      get_ctxt (fun c => app2 (app Ct (fun_codom_label Z l)) (app t (app2 (app Cs (fun_dom_label Z c l)) x)))))) 
    (eunop (blame t) l)))))) :-
      typToExpr S Cs,
      typToExpr T Ct.

typToExpr (tinter A B) (lam (bind _ (fun l => lam (bind _ (fun t => 
  app2 (app Ca (inter_label Z Y l)) (app2 (app Cb (inter_label Y Z l)) t)))))) :-
    typToExpr A Ca,
    typToExpr B Cb.

typToExpr (tunion A B) (lam (bind _ (fun l => lam (bind _ (fun t => 
  app2 (app Ca (union_label Z Y l)) (app2 (app Cb (union_label Y Z l)) t)))))) :-
    typToExpr A Ca,
    typToExpr B Cb.

typToExpr (fromExpr E) E.

(* Other *)

find : string -> list (tuple string A) -> A -> prop.
find S [] _ :- log_error S `Not found in record ${S}`, failure.
find S ((S, E) :: _) E.
find S ((S', _) :: TL) E :-
  not (eq S S'),
  find S TL E.
