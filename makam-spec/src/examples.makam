
print "Simple example without let" ?

print "Return 6" ?
interpreter "
(fun x => x + x) 3
" V T ?

print "Promises are check before running, assumes after" ?

print "Typecheck fail" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Promise(Num, true))
)
" V T ?

print "Return 3" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Assume(Num, true))
)
" V T ?

print "Blame" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, true))
)
" V T ?

print "Return 5" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, 5))
)
" V T ?

print " We don't have let polymorphism (any) " ?

print "Typecheck fail" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Promise(Num, id 3), Promise(Bool, id true))
" V T ?

print "Return 3" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Promise(Num, id 3), Assume(Bool, id true))
" V T ?

print "Return true" ?
interpreter "
let (id = fun x => x) in
Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
" V T ?

print "This is bad because order matters!!" ?

print "Typecheck fail" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Assume(Bool, id true), Promise(Num, id 3))
" V T ?

print "We can still use Assume(...)s" ?

print "Return 3" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Promise( Num , id 3), Promise( Bool, Assume( Bool -> Bool , id ) true))
" V T ?

print "Expressions can also be types!" ?

print "Void type (Blame)" ?
interpreter "
let (void = fun l => fun t => blame t l) in
Assume(void, 3)
" V T ?

print "alwaysTrue (Blame)" ?
interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
Assume(alwaysTrue, false)
" V T ?

print "Return true" ?
interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame t l)) in
Assume(alwaysTrue, true)
" V T ?

print "Return function" ?
interpreter "
let (void = fun l => fun t => blame t  l  )  in
Promise( void -> void, fun x => x) 
" V T ?

print "We also have nice recursive lets" ?

print "Return 3" ?
interpreter "
let (f = fun x => Ifte(x, f false, 3)) in
f true
" V T ?

print "Return 4 -- Shadowing works" ?
interpreter "
let (f = (let (f = fun x => 3 - x) in f 1)) in f + f
" V T ?

print "Return fun -- What happens with dangling thunks?" ?
interpreter "
let (f = fun x => x + 1) in
fun y => f y"
V T ?


print "Lets try side effects!" ?

print "Return 3 -- Lets are lazy" ?
side_effect : expr.
eval (side_effect) (eint 1) :- 
    print "Side Effect!!".

(isocast "
fun se => let (f = se) in (f + f) + f
" (E: expr), eval (app E side_effect) Res) ?

print "Return 2 -- functions as well" ?

(isocast "
fun se => (fun x => x + x) se
" (E: expr), eval (app E side_effect) Res) ?



