//! Define a type for positions (line and column) in a source, and associated helpers to
//! convert between byte offsets and positions.
use std::iter;

#[derive(Debug, PartialEq, Clone)]
pub struct Position {
    /// The absolute offset, in bytes, from the beginning of the source
    pub offset: usize,
    pub line: usize,
    pub column: usize,
}

/// Types including position information that can be converted to a human-readable string, given a
/// source mapper to convert offsets to positions. This is typically implemented for error
/// messages.
pub trait ShowWithSource {
    /// Append the representation to the string buffer `s`
    fn show_append(&self, s: &mut String, mapper: &SourceMapper);

    /// Create a fresh representation
    fn show(&self, mapper: &SourceMapper) -> String {
        let mut s = String::new();
        self.show_append(&mut s, mapper);
        s
    }
}

impl ShowWithSource for Position {
    fn show_append(&self, s: &mut String, mapper: &SourceMapper) {
        s.push_str(&format!(
            "{} line {}, column {}",
            mapper.source_name(),
            self.line,
            self.column
        ));
    }
}

/// A pair of positions models a span
impl ShowWithSource for (Position, Position) {
    fn show_append(&self, s: &mut String, mapper: &SourceMapper) {
        let (ref left, ref right) = self;
        if left.line == right.line {
            s.push_str(&format!(
                "{} line {}, columns {}-{}",
                mapper.source_name(),
                left.line,
                left.column,
                right.column
            ));
        } else {
            s.push_str(&format!(
                "{} line {}, column {}",
                mapper.source_name(),
                left.line,
                left.column
            ));
            s.push_str(&format!(" to line {}, column {}", right.line, right.column));
        }
    }
}

/// A data structure to convert from an absolute offset to a line and a column index in a source
pub struct SourceMapper {
    source_name: String,
    /// A vector containing the offsets of all line breaks, plus the initial starting offset, in ascending order
    lines: Vec<usize>,
    /// The length of the original buffer, in bytes
    length: usize,
}

impl SourceMapper {
    pub fn new(source_name: String, buffer: &str) -> SourceMapper {
        SourceMapper::new_with_offset(source_name, buffer, 0)
    }

    /// Currently, builtin contracts are simply pasted at the beginning of the source buffer. This
    /// creates a shift, as the first character of the actual input starts at offset
    /// `contracts.len()`, instead of `0`. The `start_offset` parameters specifies this offset,
    /// that will be substracted from offsets before resolution.
    pub fn new_with_offset(source_name: String, buffer: &str, start_offset: usize) -> SourceMapper {
        let bytes = buffer.as_bytes();

        let lines = {
            let lines_ = bytes
                .iter()
                .enumerate()
                .filter(|&(_, b)| *b == b'\n')
                .map(|(i, _)| i + start_offset);

            iter::once(start_offset).chain(lines_).collect()
        };

        SourceMapper {
            source_name,
            lines,
            length: buffer.len(),
        }
    }

    /// Map an absolute byte offset to a position in a file.
    ///
    /// Returns None if the offset is smaller than start_offset, meaning that the offset is located
    /// in the automatically included builtin contracts.  Panic if the offset is greater than the
    /// length of the buffer and the starting offset combined.
    pub fn map_pos(&self, offset: usize) -> Option<Position> {
        assert!(
            self.lines.len() != 0,
            "SourceMapper::map_pos: lines[0] should always contain the starting offset"
        );
        // Spans generated by the parser may end one byte after the actual last character, so we
        // accept the position self.length + self.lines[0]
        assert!(
            offset <= (self.length + self.lines[0]),
            "SourceMapper::map_pos: cannot resolve an offset ({}) greater than the length of \
             the buffer plus the starting offset ({})",
            offset,
            (self.lines[0] + self.length)
        );

        if offset < self.lines[0] {
            None
        } else {
            let (line, column) = match self.lines.binary_search(&offset) {
                Err(0) => panic!(
                    "SourceMapper::map_pos: the binary seach returned the index 0, but this \
                     is inconsistant with the previously enforced condition that offset ({}) >= \
                     start_offset ({})",
                    offset, self.lines[0]
                ),
                // The first line needs a special treatment, as self.lines[0] is the only offset
                // that does not necessarily contain a newline character (and if it does, it is
                // duplicated in the list)
                Ok(0) | Err(1) => (1, offset - self.lines[0] + 1),
                // A newline character is considered to be the last column of the previous line
                Ok(i) => (i, offset - self.lines[i - 1] + 1),
                Err(i) => (i, offset - self.lines[i - 1]),
            };

            Some(Position {
                offset: offset - self.lines[0],
                line,
                column,
            })
        }
    }

    /// Try to map a span of absolute offsets to a pair of positions. Succeed only if both offsets
    /// map to valid positions.
    pub fn map_span(&self, left: usize, right: usize) -> Option<(Position, Position)> {
        match (self.map_pos(left), self.map_pos(right)) {
            (Some(l), Some(r)) => Some((l, r)),
            _ => None,
        }
    }

    pub fn source_name(&self) -> &String {
        &self.source_name
    }
}

mod test {
    #[cfg(test)]
    use super::{Position, SourceMapper};

    #[test]
    fn source_mapping() {
        let source_name = String::from("<testing>");
        let mut start_offset = 140;
        let mut buffer = "One-line test";
        let mut mapper = SourceMapper::new_with_offset(source_name.clone(), buffer, start_offset);

        assert_eq!(
            mapper.map_pos(start_offset),
            Some(Position {
                line: 1,
                column: 1,
                offset: 0
            })
        );
        assert_eq!(
            mapper.map_pos(start_offset + 6),
            Some(Position {
                line: 1,
                column: 7,
                offset: 6
            })
        );
        assert_eq!(mapper.map_pos(start_offset - 1), None);
        assert_eq!(mapper.map_span(start_offset - 1, start_offset + 1), None);
        mapper.map_span(start_offset + 1, start_offset + 6).unwrap();

        start_offset = 2014;
        buffer = "\nTest with initial newline";
        mapper = SourceMapper::new_with_offset(source_name.clone(), buffer, start_offset);

        assert_eq!(
            mapper.map_pos(start_offset + 1),
            Some(Position {
                line: 2,
                column: 1,
                offset: 1
            })
        );
        assert_eq!(
            mapper.map_pos(start_offset + 10),
            Some(Position {
                line: 2,
                column: 10,
                offset: 10,
            })
        );

        start_offset = 341;
        buffer = "Test with final newlines\n\n";
        mapper = SourceMapper::new_with_offset(source_name.clone(), buffer, start_offset);

        assert_eq!(
            mapper.map_span(start_offset, start_offset + 24),
            Some((
                Position {
                    line: 1,
                    column: 1,
                    offset: 0
                },
                Position {
                    line: 1,
                    column: 25,
                    offset: 24
                }
            ))
        );

        start_offset = 871;
        buffer = "
            This
            is a multi-line
            test
            ";
        mapper = SourceMapper::new_with_offset(source_name.clone(), buffer, start_offset);

        assert_eq!(
            mapper.map_pos(start_offset + 25),
            Some(Position {
                line: 3,
                column: 8,
                offset: 25
            })
        );
        assert_eq!(
            mapper.map_span(start_offset + 16, start_offset + 57),
            Some((
                Position {
                    line: 2,
                    column: 16,
                    offset: 16
                },
                Position {
                    line: 4,
                    column: 12,
                    offset: 57
                }
            ))
        );
    }

    #[test]
    #[should_panic]
    fn out_of_bounds() {
        let buffer = "some buffer";
        let mapper = SourceMapper::new_with_offset(String::from("<testing>"), buffer, 100);
        mapper.map_pos(buffer.len() + 101);
    }
}
