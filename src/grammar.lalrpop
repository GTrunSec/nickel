use crate::identifier::Ident;
use crate::label::{Label, TyPath};
use crate::term::{BinaryOp, RichTerm, Term, UnaryOp};
use crate::types::{Types, AbsType};
use either::*;
use std::str::FromStr;

grammar;

pub Term: RichTerm = SpTerm<RichTerm>;

SpTerm<Rule>: RichTerm =
    <l: @L> <t: Rule> <r: @R> => match t {
        RichTerm {term: t, pos: _} => RichTerm {term: t, pos: Some((l, r))}
    };

RichTerm: RichTerm = {
    "fun" <p:Pattern> "=>" <t: SpTerm<Term>> =>
        RichTerm::new(Term::Fun(p, t)),
    "let" <id:Ident> "=" <t1:SpTerm<Term>> "in" <t2:SpTerm<Term>> =>
        RichTerm::new(Term::Let(id, t1, t2)),
    "if" <b:SpTerm<Term>> "then" <t:SpTerm<Term>> "else" <e:SpTerm<Term>> =>
        RichTerm::app(RichTerm::app(RichTerm::new(Term::Op1(UnaryOp::Ite(), b)), t), e),
    SpTerm<Operation>    
};

Operation: RichTerm = {
    <t1: SpTerm< Applicative>> <op: BOpIn> <t2: SpTerm<Operation>> => RichTerm::new(Term::Op2(op, t1, t2)),
    SpTerm< Applicative>,
};

Applicative: RichTerm = {
    <t1:SpTerm< Applicative>> <t2: SpTerm<Atom>> => RichTerm::new(Term::App(t1, t2)),
    <op: UOp> <t: SpTerm<Atom>> => RichTerm::new(Term::Op1(op, t)),
    <op: BOpPre> <t1: SpTerm<Atom>> <t2: SpTerm<Atom>> => RichTerm::new(Term::Op2(op, t1, t2)),
    <t: SpTerm<Atom>> "." <id: Ident> => RichTerm::new(Term::Op1(UnaryOp::StaticAccess(id), t)),
    <t: SpTerm<Atom>> ".$" <t_id: SpTerm<Atom>> => RichTerm::new(Term::Op2(BinaryOp::DynAccess(), t_id, t)),
    <r: SpTerm<Atom>> "$[" <id: SpTerm<Atom>> "=" <t: SpTerm<Atom>> "]" =>
        RichTerm::new(Term::Op2(BinaryOp::DynExtend(t), id, r)),
    SpTerm<Atom>,
};

Atom: RichTerm = {
    "(" <SpTerm<Term>> ")",
    <l:@L> "Promise(" <ty: Types> "," <t: SpTerm<Term>> ")" <r:@R> =>
        RichTerm::new(Term::Promise(ty, Label{tag: "A promise".to_string(), l: l, r: r, polarity: true, path: TyPath::Nil()}, t)),
    <l:@L> "Assume(" <ty: Types> "," <t: SpTerm<Term>> ")" <r:@R> =>
        RichTerm::new(Term::Assume(ty, Label{tag: "An assume".to_string(), l: l, r: r, polarity: true, path: TyPath::Nil()}, t)), 
    "Contract(" <ty: Types> ")" => RichTerm::new(Term::Contract(ty)),
    "Default(" <t: SpTerm<Term>> ")" => RichTerm::new(Term::DefaultValue(t)),
    "ContractDefault(" <ty: Types> "," <t: SpTerm<Term>> ")" => RichTerm::new(Term::ContractWithDefault(ty, t)),
    "Docstring(" <s: Str> "," <t: SpTerm<Term>> ")" => RichTerm::new(Term::Docstring(s, t)),
    Num => RichTerm::new(Term::Num(<>)),
    Bool => RichTerm::new(Term::Bool(<>)),
    Str => RichTerm::new(Term::Str(<>)),
    Ident => RichTerm::new(Term::Var(<>)),
    "`" <Ident> => RichTerm::new(Term::Enum(<>)),
    "{" <fields: (RecordField ";")*> "}" => 
    fields.clone().into_iter().map(|x| x.0).filter_map(
        |x| match x {Left(_) => None, Right(y) => Some(y)}
    ).fold(
        RichTerm::new(Term::Record(
            fields.clone().into_iter().map(|x| x.0).filter_map(
                |x| match x {Left(y) => Some(y), Right(_) => None}
            ).collect()
        )),
        | acc, e | {
            let (id_t, t) = e;
            RichTerm::new(Term::Op2(
                BinaryOp::DynExtend(t),
                id_t,
                acc
            ))
        }
    ),
    "[" <terms: (SpTerm<Atom> ",")*> <last: SpTerm<Atom>?> "]" => {
        let mut terms : Vec<RichTerm> = terms.clone().into_iter().map(|x| x.0).collect();
        if let Some(t) = last {
            terms.push(t);
        }

        RichTerm::new(Term::List(terms))
    }
};

RecordField: Either<(Ident, RichTerm), (RichTerm, RichTerm)> = {
    <id: Ident> "=" <t: SpTerm<Atom>> => 
        Either::Left((id, t)),
    "$" <id: SpTerm<Term>> "=" <t: SpTerm<Atom>> => 
        Either::Right((id, t)),
}

Pattern: Ident = {
    Ident,
};

Ident: Ident = r"[[:alpha:]_][[:word:]-]*" => Ident(<>.to_string());

Num: f64 = r"[-+]?[0-9]*\.?[0-9]+" => f64::from_str(<>).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
};

Str: String = {
    <x:r#""(([^\\"]|\\.)*)""#> => x[1..(x.len() - 1)].to_string(),
}

UOp: UnaryOp<RichTerm> = {
    "isZero" => UnaryOp::IsZero(),
    "isNum" => UnaryOp::IsNum(),
    "isBool" => UnaryOp::IsBool(),
    "isStr" => UnaryOp::IsStr(),
    "isFun" => UnaryOp::IsFun(),
    "isList" => UnaryOp::IsList(),
    "blame" => UnaryOp::Blame(),
    "chngPol" => UnaryOp::ChangePolarity(),
    "polarity" => UnaryOp::Pol(),
    "goDom" => UnaryOp::GoDom(),
    "goCodom" => UnaryOp::GoCodom(),
    "tag[" <DbgStr> "]" => UnaryOp::Tag(<>),
    "wrap" => UnaryOp::Wrap(),
    "embed" <Ident> => UnaryOp::Embed(<>),
    "switch" "{" <ds: (switch_case ",")*> <default: switch_default?> "}" => 
        UnaryOp::Switch(
            ds.into_iter().map(|x| x.0).collect(),
            default,
        ),
    "mapRec" <Atom> => UnaryOp::MapRec(<>),
    "seq" => UnaryOp::Seq(),
    "deepSeq" => UnaryOp::DeepSeq(),
    "head" => UnaryOp::ListHead(),
    "tail" => UnaryOp::ListTail(),
    "length" => UnaryOp::ListLength(),
};

switch_case: (Ident, RichTerm) = {
    <id: Ident> "=>" <t: SpTerm<Atom> > => (id, t),
}

switch_default: RichTerm = {
    "_" "=>" <SpTerm<Atom>> "," => <>,
}

BOpIn: BinaryOp<RichTerm> = {
    "+" => BinaryOp::Plus(),
    "++" => BinaryOp::PlusStr(),
    "=b" => BinaryOp::EqBool(),
    "-$" => BinaryOp::DynRemove(),
    "@" => BinaryOp::ListConcat(),

};

BOpPre: BinaryOp<RichTerm> = {
    "unwrap" => BinaryOp::Unwrap(),
    "hasField" => BinaryOp::HasField(),
    "map" => BinaryOp::ListMap(),
    "elemAt" => BinaryOp::ListElemAt(),
    "merge" => BinaryOp::Merge(),
}

Types: Types = {
    "forall" <id: Ident> "." <ty: Arrows> => Types(AbsType::Forall(id, Box::new(ty))),
    <Arrows>
}

Arrows: Types = {
    <s: subType> "->" <t:Arrows> => Types(AbsType::Arrow(Box::new(s), Box::new(t))),
    <subType>,
};

subType : Types = {
    "Dyn" => Types(AbsType::Dyn()),
    "Num" => Types(AbsType::Num()),
    "Bool" => Types(AbsType::Bool()),
    "Str" => Types(AbsType::Str()),
    "List" => Types(AbsType::List()),
    <Ident> => Types(AbsType::Var(<>)),
    "#" <SpTerm<RichTerm>> => Types(AbsType::Flat(<>)),
    "(" <Types> ")" => <>,
    "(|" <r:(<Ident> ",")*> "|" <rest: Ident?> ")" => 
        r.iter().fold(
            Types(
                match rest {
                    Some(id) => AbsType::Var(id),
                    None => AbsType::RowEmpty(),
                }
            ),
            |t, i| Types(AbsType::RowExtend(i.clone(), None, Box::new(t)))), 
    "{|" <r:(<Ident> ":" <Types> ",")*> "|" <rest: Ident?> "}" => 
        r.iter().fold(
            Types(
                match rest {
                    Some(id) => AbsType::Var(id),
                    None => AbsType::RowEmpty(),
                }
            ),
            |t, i_ty| {
                let (i, ty) = i_ty;
                Types(AbsType::RowExtend(i.clone(), Some(Box::new(ty.clone())), Box::new(t)))
            }), 
    "<" <subType> ">" => Types(AbsType::Enum(Box::new(<>))),
    "{" <subType> "}" => Types(AbsType::StaticRecord(Box::new(<>))),
    "{" "_" ":" <subType> "}" => Types(AbsType::DynRecord(Box::new(<>))),
};

DbgStr: String = r"[[:alpha:]_][[:word:]-]*" => <>.to_string();
